# Arquitectura T√©cnica - Sistema de Gesti√≥n de Tickets

## üìã √çndice de la Explicaci√≥n T√©cnica

Esta gu√≠a te llevar√° paso a paso a trav√©s de toda la arquitectura, desde el punto de entrada hasta los componentes m√°s espec√≠ficos.

---

## üéØ Orden de Presentaci√≥n Recomendado

```
1. Program.cs - Punto de entrada y configuraci√≥n
2. Estructura de carpetas - Organizaci√≥n del proyecto
3. Models - Capa de datos
4. Services - L√≥gica de negocio
5. Components/Layout - Estructura visual base
6. Components/Pages - P√°ginas principales
7. Components/Tickets - Componentes espec√≠ficos
8. Flujo de datos - C√≥mo interact√∫an las capas
9. Caracter√≠sticas t√©cnicas clave
```

---

# PARTE 1: PUNTO DE ENTRADA

## üìÑ 1. Program.cs - El Coraz√≥n de la Aplicaci√≥n

**Ubicaci√≥n**: `TicketManagementApp/Program.cs`

### ¬øQu√© es?
Es el punto de entrada de la aplicaci√≥n. Configura todos los servicios, middleware y la aplicaci√≥n Blazor.

### C√≥digo Explicado L√≠nea por L√≠nea:

```csharp
using TicketManagementApp.Components;
using TicketManagementApp.Services;
```
**L√≠neas 1-2**: Importamos los namespaces necesarios:
- `Components`: Donde est√°n todos nuestros componentes Razor
- `Services`: Donde est√° la l√≥gica de negocio

```csharp
var builder = WebApplication.CreateBuilder(args);
```
**L√≠nea 4**: Crea el constructor de la aplicaci√≥n web. Este objeto `builder` se usa para configurar todo antes de ejecutar la app.

```csharp
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();
```
**L√≠neas 6-7**:
- `AddRazorComponents()`: Habilita los componentes Razor (archivos .razor)
- `AddInteractiveServerComponents()`: Habilita el modo interactivo de Blazor Server
  - Esto permite que la UI responda en tiempo real sin recargar la p√°gina
  - Usa SignalR por debajo para comunicaci√≥n en tiempo real

```csharp
builder.Services.AddSingleton<ITicketService, TicketService>();
```
**L√≠nea 11**: **MUY IMPORTANTE** - Inyecci√≥n de Dependencias (DI)
- Registra el servicio `TicketService` como un Singleton
- `Singleton`: Una sola instancia para toda la aplicaci√≥n
- `ITicketService`: Interfaz (contrato)
- `TicketService`: Implementaci√≥n concreta
- Esto permite usar `@inject ITicketService` en cualquier componente

```csharp
var app = builder.Build();
```
**L√≠nea 13**: Construye la aplicaci√≥n con toda la configuraci√≥n anterior.

```csharp
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    app.UseHsts();
}
```
**L√≠neas 15-19**: Configuraci√≥n de seguridad para PRODUCCI√ìN:
- Si NO estamos en desarrollo, usa manejo de errores global
- HSTS: Fuerza HTTPS en producci√≥n

```csharp
app.UseHttpsRedirection();
app.UseAntiforgery();
```
**L√≠neas 21-22**:
- Redirige HTTP a HTTPS autom√°ticamente
- Antiforgery: Protecci√≥n contra ataques CSRF

```csharp
app.MapStaticAssets();
```
**L√≠nea 24**: Mapea archivos est√°ticos (CSS, JS, im√°genes) para que se sirvan correctamente.

```csharp
app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();
```
**L√≠neas 25-26**: Configura el enrutamiento de componentes Razor:
- `<App>`: Componente ra√≠z de la aplicaci√≥n
- `AddInteractiveServerRenderMode()`: Habilita interactividad del lado del servidor

```csharp
app.Run();
```
**L√≠nea 28**: Inicia la aplicaci√≥n y comienza a escuchar peticiones.

### Conceptos Clave:
- ‚úÖ **Inyecci√≥n de Dependencias**: Pattern para desacoplar c√≥digo
- ‚úÖ **Blazor Server**: Renderizado del lado del servidor con interactividad
- ‚úÖ **SignalR**: Comunicaci√≥n en tiempo real (usado por Blazor Server)
- ‚úÖ **Singleton**: Una sola instancia del servicio para toda la app

---

# PARTE 2: ESTRUCTURA DEL PROYECTO

## üìÅ 2. Estructura de Carpetas - Organizaci√≥n

```
TicketManagementApp/
‚îÇ
‚îú‚îÄ‚îÄ Program.cs                    ‚≠ê PUNTO DE ENTRADA
‚îÇ
‚îú‚îÄ‚îÄ Models/                       üìä CAPA DE DATOS
‚îÇ   ‚îú‚îÄ‚îÄ Ticket.cs                 ‚Üí Modelo principal
‚îÇ   ‚îî‚îÄ‚îÄ TicketStatus.cs           ‚Üí Enum de estados
‚îÇ
‚îú‚îÄ‚îÄ Services/                     üîß L√ìGICA DE NEGOCIO
‚îÇ   ‚îú‚îÄ‚îÄ ITicketService.cs         ‚Üí Contrato (interfaz)
‚îÇ   ‚îî‚îÄ‚îÄ TicketService.cs          ‚Üí Implementaci√≥n
‚îÇ
‚îú‚îÄ‚îÄ Data/                         üíæ DATOS MOCK
‚îÇ   ‚îî‚îÄ‚îÄ tickets.json              ‚Üí 10 tickets de ejemplo
‚îÇ
‚îú‚îÄ‚îÄ Components/                   üé® COMPONENTES VISUALES
‚îÇ   ‚îú‚îÄ‚îÄ App.razor                 ‚Üí Componente ra√≠z
‚îÇ   ‚îú‚îÄ‚îÄ Routes.razor              ‚Üí Configuraci√≥n de rutas
‚îÇ   ‚îú‚îÄ‚îÄ _Imports.razor            ‚Üí Imports globales
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Layout/                   üìê ESTRUCTURA BASE
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MainLayout.razor      ‚Üí Layout principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MainLayout.razor.css  ‚Üí Estilos del layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavMenu.razor         ‚Üí Men√∫ de navegaci√≥n
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NavMenu.razor.css     ‚Üí Estilos del men√∫
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Pages/                    üìÑ P√ÅGINAS PRINCIPALES
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Home.razor            ‚Üí P√°gina de inicio (/)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Home.razor.css        ‚Üí Estilos de Home
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Tickets.razor         ‚Üí Dashboard de tickets (/tickets)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Tickets.razor.css     ‚Üí Estilos del dashboard
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Error.razor           ‚Üí P√°gina de errores
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Tickets/                  üé´ COMPONENTES ESPEC√çFICOS
‚îÇ       ‚îú‚îÄ‚îÄ TicketFilters.razor        ‚Üí B√∫squeda y filtros
‚îÇ       ‚îú‚îÄ‚îÄ TicketFilters.razor.css    ‚Üí Estilos de filtros
‚îÇ       ‚îú‚îÄ‚îÄ TicketList.razor           ‚Üí Lista de tickets
‚îÇ       ‚îú‚îÄ‚îÄ TicketList.razor.css       ‚Üí Estilos de lista
‚îÇ       ‚îú‚îÄ‚îÄ TicketDetail.razor         ‚Üí Modal de detalle
‚îÇ       ‚îî‚îÄ‚îÄ TicketDetail.razor.css     ‚Üí Estilos del modal
‚îÇ
‚îî‚îÄ‚îÄ wwwroot/                      üåê ARCHIVOS EST√ÅTICOS
    ‚îú‚îÄ‚îÄ app.css                   ‚Üí Estilos globales
    ‚îî‚îÄ‚îÄ lib/                      ‚Üí Librer√≠as (Bootstrap)
```

### Principios de Organizaci√≥n:

1. **Separaci√≥n de Responsabilidades**: Cada carpeta tiene un prop√≥sito claro
2. **Models**: Solo definen la estructura de datos (POCOs)
3. **Services**: Toda la l√≥gica de negocio y acceso a datos
4. **Components**: Solo l√≥gica de presentaci√≥n e interactividad
5. **CSS Isolated**: Cada componente tiene su propio archivo CSS

---

# PARTE 3: MODELOS DE DATOS

## üìä 3. Models/TicketStatus.cs - Enum de Estados

**Ubicaci√≥n**: `Models/TicketStatus.cs`

```csharp
namespace TicketManagementApp.Models;

public enum TicketStatus
{
    Abierto,
    EnProgreso,
    Cerrado
}
```

### ¬øPor qu√© un Enum?
- ‚úÖ **Type Safety**: No se pueden usar valores inv√°lidos
- ‚úÖ **IntelliSense**: Autocompletado en el IDE
- ‚úÖ **Refactoring**: F√°cil de renombrar

### Uso:
```csharp
var status = TicketStatus.Abierto;
// No puedes hacer: var status = "Abiert0" (typo)
```

---

## üìä 4. Models/Ticket.cs - Modelo Principal

**Ubicaci√≥n**: `Models/Ticket.cs`

```csharp
using System.Text.Json.Serialization;

namespace TicketManagementApp.Models;

public class Ticket
{
    [JsonPropertyName("id")]
    public int Id { get; set; }

    [JsonPropertyName("title")]
    public string Title { get; set; } = string.Empty;

    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    [JsonPropertyName("status")]
    public string Status { get; set; } = "Abierto";

    [JsonPropertyName("createdAt")]
    public DateTime CreatedAt { get; set; }
```

### Explicaci√≥n Detallada:

**Atributo `[JsonPropertyName]`**:
- Mapea las propiedades de C# a las propiedades del JSON
- Ejemplo: `Id` en C# ‚Üî `"id"` en JSON
- Permite usar convenciones de C# (PascalCase) y JSON (camelCase)

**Propiedades con Valores por Defecto**:
```csharp
public string Title { get; set; } = string.Empty;
```
- Inicializa con cadena vac√≠a en lugar de `null`
- Evita `NullReferenceException`
- Cumple con `Nullable Reference Types` de C# 9.0+

**M√©todos Helper**:
```csharp
public TicketStatus GetTicketStatus()
{
    return Status switch
    {
        "Abierto" => TicketStatus.Abierto,
        "En progreso" => TicketStatus.EnProgreso,
        "Cerrado" => TicketStatus.Cerrado,
        _ => TicketStatus.Abierto
    };
}
```
- **Pattern Matching**: Switch moderno de C#
- Convierte `string` a `enum`
- `_`: Caso por defecto (default)

```csharp
public void SetTicketStatus(TicketStatus status)
{
    Status = status switch
    {
        TicketStatus.Abierto => "Abierto",
        TicketStatus.EnProgreso => "En progreso",
        TicketStatus.Cerrado => "Cerrado",
        _ => "Abierto"
    };
}
```
- Convierte `enum` a `string`
- √ötil para serializar a JSON

### Concepto Clave: POCO (Plain Old CLR Object)
- Clase simple con solo propiedades
- Sin l√≥gica de negocio compleja
- F√°cil de serializar/deserializar

---

# PARTE 4: CAPA DE SERVICIOS

## üîß 5. Services/ITicketService.cs - Contrato del Servicio

**Ubicaci√≥n**: `Services/ITicketService.cs`

```csharp
using TicketManagementApp.Models;

namespace TicketManagementApp.Services;

public interface ITicketService
{
    Task<List<Ticket>> GetAllTicketsAsync();
    Task<Ticket?> GetTicketByIdAsync(int id);
    Task<bool> UpdateTicketStatusAsync(int id, string newStatus);
}
```

### ¬øPor qu√© una Interfaz?

1. **Abstracci√≥n**: Define QU√â hace el servicio, no C√ìMO
2. **Testabilidad**: F√°cil de crear mocks para pruebas
3. **Inyecci√≥n de Dependencias**: Se inyecta `ITicketService`, no `TicketService`
4. **Flexibilidad**: Podemos cambiar la implementaci√≥n sin tocar los componentes

### Dise√±o de la API:

**GET /tickets** ‚Üí `GetAllTicketsAsync()`
- Retorna lista completa de tickets
- `Task<List<Ticket>>`: Operaci√≥n as√≠ncrona

**GET /tickets/{id}** ‚Üí `GetTicketByIdAsync(int id)`
- Retorna un ticket espec√≠fico
- `Ticket?`: Puede retornar `null` si no existe

**PATCH /tickets/{id}** ‚Üí `UpdateTicketStatusAsync(int id, string newStatus)`
- Actualiza solo el estado
- `Task<bool>`: Retorna √©xito/fracaso

---

## üîß 6. Services/TicketService.cs - Implementaci√≥n

**Ubicaci√≥n**: `Services/TicketService.cs`

### Constructor e Inyecci√≥n de Dependencias:

```csharp
private readonly IWebHostEnvironment _environment;
private readonly ILogger<TicketService> _logger;
private List<Ticket> _tickets;

public TicketService(IWebHostEnvironment environment, ILogger<TicketService> logger)
{
    _environment = environment;
    _logger = logger;
    _tickets = new List<Ticket>();
    LoadTickets();
}
```

**Inyecci√≥n de Dependencias**:
- `IWebHostEnvironment`: Info del entorno (Development, Production, rutas)
- `ILogger<TicketService>`: Sistema de logging integrado de .NET

**Patr√≥n Constructor Injection**:
- ASP.NET Core inyecta autom√°ticamente estas dependencias
- No necesitamos crear instancias manualmente

### Carga de Datos:

```csharp
private void LoadTickets()
{
    try
    {
        var jsonPath = Path.Combine(_environment.ContentRootPath, "Data", "tickets.json");
        _logger.LogInformation($"Intentando cargar tickets desde: {jsonPath}");

        if (!File.Exists(jsonPath))
        {
            _logger.LogWarning($"Archivo tickets.json no encontrado. Usando datos en memoria.");
            LoadInMemoryData();
            return;
        }

        var jsonContent = File.ReadAllText(jsonPath);
        _tickets = JsonSerializer.Deserialize<List<Ticket>>(jsonContent) ?? new List<Ticket>();
        _logger.LogInformation($"Cargados {_tickets.Count} tickets desde el archivo JSON");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error al cargar los tickets. Usando datos en memoria.");
        LoadInMemoryData();
    }
}
```

**Caracter√≠sticas T√©cnicas**:

1. **Fallback Pattern**: Si falla cargar JSON, usa datos en memoria
2. **Logging Estructurado**: Usa ILogger para diagn√≥stico
3. **Deserializaci√≥n JSON**: Usa `System.Text.Json`
4. **Null Coalescing**: `?? new List<Ticket>()` - Si deserializa null, crea lista vac√≠a

### Simulaci√≥n de API con Latencia:

```csharp
public async Task<List<Ticket>> GetAllTicketsAsync()
{
    // Simulando latencia de red
    await Task.Delay(300);
    return _tickets.ToList();
}
```

**¬øPor qu√© `Task.Delay(300)`?**
- Simula una llamada HTTP real (~300ms de latencia)
- Permite ver el estado de "Cargando..." en la UI
- M√°s realista para demostraci√≥n

**¬øPor qu√© `.ToList()`?**
- Crea una copia de la lista
- Evita que componentes modifiquen directamente `_tickets`
- **Defensive Programming**

### Actualizaci√≥n de Estado (PATCH):

```csharp
public async Task<bool> UpdateTicketStatusAsync(int id, string newStatus)
{
    await Task.Delay(400); // Latencia simulada

    var ticket = _tickets.FirstOrDefault(t => t.Id == id);
    if (ticket == null)
    {
        _logger.LogWarning($"Ticket con ID {id} no encontrado");
        return false;
    }

    var validStatuses = new[] { "Abierto", "En progreso", "Cerrado" };
    if (!validStatuses.Contains(newStatus))
    {
        _logger.LogWarning($"Estado inv√°lido: {newStatus}");
        return false;
    }

    ticket.Status = newStatus;
    _logger.LogInformation($"Ticket {id} actualizado a estado: {newStatus}");
    return true;
}
```

**Validaciones**:
1. ‚úÖ Verifica que el ticket existe
2. ‚úÖ Valida que el nuevo estado es correcto
3. ‚úÖ Registra el cambio en logs
4. ‚úÖ Retorna √©xito/fracaso

**Patr√≥n Repository**:
- El servicio abstrae el acceso a datos
- Los componentes no saben si los datos vienen de JSON, DB, o API
- F√°cil de cambiar la fuente de datos en el futuro

---

# PARTE 5: COMPONENTES DE LAYOUT

## üìê 7. Components/Layout/MainLayout.razor - Estructura Base

**Ubicaci√≥n**: `Components/Layout/MainLayout.razor`

Este componente define la estructura HTML base de TODAS las p√°ginas.

```razor
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <!-- Header aqu√≠ -->
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>
```

**`@inherits LayoutComponentBase`**:
- Hereda de la clase base de layouts en Blazor
- Proporciona la propiedad `@Body`

**`@Body`**:
- Placeholder donde se renderizan las p√°ginas
- Cuando navegas a `/tickets`, aqu√≠ se inserta `Tickets.razor`

**Estructura**:
- `sidebar`: Men√∫ de navegaci√≥n (fijo a la izquierda)
- `main`: Contenido principal de la p√°gina

---

## üìê 8. Components/Layout/NavMenu.razor - Men√∫ de Navegaci√≥n

**Ubicaci√≥n**: `Components/Layout/NavMenu.razor`

```razor
<div class="nav-scrollable">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="tickets">
                <span class="bi bi-envelope-fill-nav-menu"></span> Tickets
            </NavLink>
        </div>
    </nav>
</div>
```

**Componente `<NavLink>`**:
- Componente especial de Blazor para navegaci√≥n
- A√±ade autom√°ticamente clase `active` cuando la ruta coincide
- `Match="NavLinkMatch.All"`: Coincide solo cuando la URL es EXACTAMENTE "/"

**CSS Isolated**:
- `NavMenu.razor.css` solo afecta a este componente
- Los estilos NO se filtran a otros componentes
- Blazor genera clases √∫nicas autom√°ticamente

---

# PARTE 6: P√ÅGINAS PRINCIPALES

## üìÑ 9. Components/Pages/Home.razor - P√°gina de Inicio

**Ubicaci√≥n**: `Components/Pages/Home.razor`

```razor
@page "/"
@inject NavigationManager Navigation
@rendermode InteractiveServer
```

**Directivas de P√°gina**:

**`@page "/"`**:
- Define la ruta de esta p√°gina
- Esta p√°gina se muestra cuando navegas a la ra√≠z del sitio

**`@inject NavigationManager Navigation`**:
- Inyecta el servicio de navegaci√≥n
- Permite navegar program√°ticamente: `Navigation.NavigateTo("/tickets")`

**`@rendermode InteractiveServer`**: ‚≠ê CR√çTICO
- Habilita la interactividad en esta p√°gina
- Sin esto, los eventos `@onclick` NO funcionan
- Blazor Server necesita esto para establecer la conexi√≥n SignalR

### Navegaci√≥n Program√°tica:

```razor
<button class="btn-primary-home" @onclick="GoToTickets">
    Ir al Dashboard de Tickets
</button>

@code {
    private void GoToTickets()
    {
        Navigation.NavigateTo("/tickets");
    }
}
```

**Flujo de Evento**:
1. Usuario hace clic en el bot√≥n
2. Blazor Server captura el evento v√≠a SignalR
3. Ejecuta `GoToTickets()` en el servidor
4. `NavigationManager` cambia la ruta a `/tickets`
5. Blazor renderiza `Tickets.razor` en el cliente

---

## üìÑ 10. Components/Pages/Tickets.razor - Dashboard Principal

**Ubicaci√≥n**: `Components/Pages/Tickets.razor`

### Estructura y Directivas:

```razor
@page "/tickets"
@using TicketManagementApp.Models
@using TicketManagementApp.Services
@using TicketManagementApp.Components.Tickets
@inject ITicketService TicketService
@rendermode InteractiveServer
```

**`@using`**:
- Importa namespaces para usar dentro del componente
- Evita escribir `TicketManagementApp.Models.Ticket` cada vez

**`@inject ITicketService TicketService`**:
- Inyecta el servicio que registramos en `Program.cs`
- Blazor resuelve autom√°ticamente la dependencia

### Estado del Componente:

```csharp
@code {
    private List<Ticket> allTickets = new();
    private List<Ticket> filteredTickets = new();
    private Ticket? selectedTicket;
    private bool isLoading = true;
    private string? errorMessage;
    private string currentFilter = "Todos";
    private string currentSearch = "";
```

**Variables de Estado**:
- `allTickets`: Lista original sin filtrar
- `filteredTickets`: Lista despu√©s de aplicar filtros/b√∫squeda
- `selectedTicket`: Ticket abierto en el modal (null si est√° cerrado)
- `isLoading`: Control del spinner de carga
- `currentFilter`: Estado actual del filtro ("Todos", "Abierto", etc.)
- `currentSearch`: Texto de b√∫squeda actual

### Ciclo de Vida del Componente:

```csharp
protected override async Task OnInitializedAsync()
{
    try
    {
        await LoadTickets();
    }
    catch (Exception ex)
    {
        errorMessage = $"Error al cargar los tickets: {ex.Message}";
    }
    finally
    {
        isLoading = false;
    }
}
```

**`OnInitializedAsync()`**:
- Se ejecuta UNA VEZ cuando el componente se carga
- Perfecto para cargar datos iniciales
- `async`: Permite usar `await` para operaciones as√≠ncronas

**Patr√≥n try-catch-finally**:
- `try`: Intenta cargar los tickets
- `catch`: Si falla, guarda el mensaje de error
- `finally`: Siempre oculta el spinner (pase lo que pase)

### L√≥gica de Filtrado:

```csharp
private void ApplyFilters()
{
    filteredTickets = allTickets;

    if (currentFilter != "Todos")
    {
        filteredTickets = filteredTickets.Where(t => t.Status == currentFilter).ToList();
    }

    if (!string.IsNullOrWhiteSpace(currentSearch))
    {
        filteredTickets = filteredTickets.Where(t =>
            t.Title.Contains(currentSearch, StringComparison.OrdinalIgnoreCase) ||
            t.Description.Contains(currentSearch, StringComparison.OrdinalIgnoreCase)
        ).ToList();
    }
}
```

**LINQ (Language Integrated Query)**:
- `.Where()`: Filtra elementos que cumplan la condici√≥n
- `.Contains()`: Busca substring
- `StringComparison.OrdinalIgnoreCase`: Ignora may√∫sculas/min√∫sculas

**Filtrado Combinado**:
1. Primero aplica filtro de estado
2. Luego aplica b√∫squeda de texto
3. El resultado es la intersecci√≥n de ambos filtros

### Comunicaci√≥n con Componentes Hijos:

```razor
<TicketFilters
    OnFilterChanged="HandleFilterChange"
    OnSearchChanged="HandleSearchChange" />
```

**EventCallback**:
- El componente hijo (`TicketFilters`) notifica al padre
- Cuando el usuario cambia el filtro, llama a `HandleFilterChange`
- **Flujo unidireccional de datos** (como React)

```csharp
private void HandleFilterChange(string filter)
{
    currentFilter = filter;
    ApplyFilters();
}
```

### Renderizado Condicional:

```razor
@if (isLoading)
{
    <div class="loading-container">
        <div class="spinner"></div>
        <p>Cargando tickets...</p>
    </div>
}
else if (errorMessage != null)
{
    <div class="error-message">
        <span class="error-icon">‚ö†</span>
        <p>@errorMessage</p>
    </div>
}
else
{
    <!-- Muestra los tickets -->
}
```

**Estados de la UI**:
1. **Loading**: Muestra spinner mientras carga
2. **Error**: Muestra mensaje si algo falla
3. **Success**: Muestra los tickets

---

# PARTE 7: COMPONENTES ESPEC√çFICOS

## üé´ 11. Components/Tickets/TicketFilters.razor - B√∫squeda y Filtros

**Ubicaci√≥n**: `Components/Tickets/TicketFilters.razor`

### Par√°metros del Componente:

```csharp
[Parameter]
public EventCallback<string> OnFilterChanged { get; set; }

[Parameter]
public EventCallback<string> OnSearchChanged { get; set; }
```

**`[Parameter]`**:
- Atributo que marca propiedades que se pasan desde el padre
- Similar a `props` en React o `@Input()` en Angular

**`EventCallback<T>`**:
- Tipo especial de Blazor para callbacks
- As√≠ncrono por defecto
- `T`: Tipo del par√°metro que se pasa al callback

### Input de B√∫squeda en Tiempo Real:

```razor
<input
    type="text"
    placeholder="Buscar tickets..."
    value="@searchText"
    @oninput="OnSearchInput"
    class="search-input" />
```

**`value="@searchText"`**:
- Enlace ONE-WAY (solo lectura)
- La UI muestra el valor de `searchText`

**`@oninput="OnSearchInput"`**:
- Se ejecuta en CADA tecla presionada
- B√∫squeda en tiempo real (no necesita Enter)

**¬øPor qu√© no `@bind`?**:
- `@bind` tiene un delay (solo actualiza al perder foco)
- `@oninput` es inmediato (cada keystroke)

```csharp
private async Task OnSearchInput(ChangeEventArgs e)
{
    searchText = e.Value?.ToString() ?? "";
    await OnSearchChanged.InvokeAsync(searchText);
}
```

**`ChangeEventArgs`**:
- Contiene informaci√≥n del evento
- `e.Value`: Nuevo valor del input

**`InvokeAsync()`**:
- Invoca el callback del padre
- El padre (`Tickets.razor`) recibe el nuevo texto de b√∫squeda

### Botones de Filtro:

```razor
<button
    class="filter-btn @(selectedFilter == "Abierto" ? "active" : "")"
    @onclick="@(() => SelectFilter("Abierto"))">
    Abiertos
</button>
```

**Clases Din√°micas**:
```razor
class="filter-btn @(selectedFilter == "Abierto" ? "active" : "")"
```
- Si `selectedFilter == "Abierto"`, a√±ade clase `active`
- Permite resaltar el bot√≥n activo con CSS

**Lambda en `@onclick`**:
```razor
@onclick="@(() => SelectFilter("Abierto"))"
```
- Lambda que llama al m√©todo con par√°metro
- Sin lambda, no podr√≠amos pasar el par√°metro

---

## üé´ 12. Components/Tickets/TicketList.razor - Lista de Tickets

**Ubicaci√≥n**: `Components/Tickets/TicketList.razor`

### Par√°metro de Entrada:

```csharp
[Parameter]
public List<Ticket> Tickets { get; set; } = new();

[Parameter]
public EventCallback<int> OnTicketSelected { get; set; }
```

**Flujo de Datos**:
- Padre ‚Üí Hijo: `Tickets` (lista de tickets a mostrar)
- Hijo ‚Üí Padre: `OnTicketSelected` (ID del ticket clickeado)

### Iteraci√≥n con `@foreach`:

```razor
@foreach (var ticket in Tickets)
{
    <div class="ticket-card" @onclick="() => SelectTicket(ticket.Id)">
        <h3>@ticket.Title</h3>
        <p>@TruncateDescription(ticket.Description)</p>
        <span class="ticket-status status-@GetStatusClass(ticket.Status)">
            @ticket.Status
        </span>
    </div>
}
```

**`@foreach`**:
- Itera sobre la lista de tickets
- Genera HTML din√°micamente para cada ticket

**M√©todos Helper**:

```csharp
private string TruncateDescription(string description)
{
    if (description.Length <= 100)
        return description;
    return description.Substring(0, 100) + "...";
}
```
- Limita la descripci√≥n a 100 caracteres
- A√±ade "..." si es m√°s larga
- Mejor UX: no muestra texto infinito

```csharp
private string GetStatusClass(string status)
{
    return status switch
    {
        "Abierto" => "open",
        "En progreso" => "progress",
        "Cerrado" => "closed",
        _ => "open"
    };
}
```
- Mapea estado a clase CSS
- Permite colorear badges seg√∫n el estado
- `status-open`, `status-progress`, `status-closed`

```csharp
private string FormatDate(DateTime date)
{
    var timeSpan = DateTime.Now - date;
    if (timeSpan.TotalDays < 1)
        return $"Hace {(int)timeSpan.TotalHours}h";
    if (timeSpan.TotalDays < 7)
        return $"Hace {(int)timeSpan.TotalDays}d";
    return date.ToString("dd/MM/yyyy");
}
```
- Formato de fecha "inteligente"
- Reciente: "Hace 2h", "Hace 3d"
- Antiguo: "15/10/2025"
- Mejor UX: informaci√≥n relativa

---

## üé´ 13. Components/Tickets/TicketDetail.razor - Modal de Detalle

**Ubicaci√≥n**: `Components/Tickets/TicketDetail.razor`

### Estructura del Modal:

```razor
<div class="modal-overlay" @onclick="Close">
    <div class="ticket-detail-panel" @onclick:stopPropagation="true">
        <!-- Contenido del modal -->
    </div>
</div>
```

**`@onclick:stopPropagation="true"`**: ‚≠ê IMPORTANTE
- Evita que el clic en el panel cierre el modal
- Solo hacer clic FUERA del panel (overlay) cierra el modal
- Sin esto, cualquier clic cerrar√≠a el modal

### Par√°metros:

```csharp
[Parameter]
public Ticket Ticket { get; set; } = null!;

[Parameter]
public EventCallback OnClose { get; set; }

[Parameter]
public EventCallback<(int id, string status)> OnStatusChanged { get; set; }
```

**`null!`**:
- Null-forgiving operator
- Le dice al compilador: "Conf√≠a en m√≠, no ser√° null"
- El padre SIEMPRE pasa un Ticket v√°lido

**Tuple en EventCallback**:
```csharp
EventCallback<(int id, string status)>
```
- Pasa m√∫ltiples valores al padre
- Sintaxis moderna de C# (tuples)

### Botones de Cambio de Estado:

```razor
<button
    class="status-btn status-btn-open @(Ticket.Status == "Abierto" ? "active" : "")"
    @onclick="@(() => ChangeStatus("Abierto"))"
    disabled="@(Ticket.Status == "Abierto" || isUpdating)">
    Abierto
</button>
```

**Disabled Din√°mico**:
```razor
disabled="@(Ticket.Status == "Abierto" || isUpdating)"
```
- Deshabilita si ya est√° en ese estado
- Deshabilita durante la actualizaci√≥n (evita doble clic)

### L√≥gica de Cambio de Estado:

```csharp
private async Task ChangeStatus(string newStatus)
{
    if (isUpdating || Ticket.Status == newStatus)
        return;

    isUpdating = true;
    await OnStatusChanged.InvokeAsync((Ticket.Id, newStatus));
    isUpdating = false;
}
```

**Guard Clauses**:
- Primera l√≠nea verifica precondiciones
- Si ya est√° actualizando o el estado es el mismo, sale
- **Defensive Programming**

**Estado `isUpdating`**:
- Muestra mensaje "Actualizando estado..."
- Deshabilita todos los botones
- Evita m√∫ltiples clics simult√°neos

---

# PARTE 8: FLUJO DE DATOS COMPLETO

## üîÑ 14. Flujo de Ejecuci√≥n: Cambio de Estado

Vamos a seguir el flujo completo cuando el usuario cambia el estado de un ticket:

### Paso 1: Usuario Hace Clic en Bot√≥n (TicketDetail.razor)

```razor
<button @onclick="@(() => ChangeStatus("En progreso"))">
    En Progreso
</button>
```

1. Usuario hace clic
2. Blazor Server captura el evento v√≠a SignalR
3. Ejecuta `ChangeStatus("En progreso")` en el servidor

### Paso 2: M√©todo `ChangeStatus` (TicketDetail.razor)

```csharp
private async Task ChangeStatus(string newStatus)
{
    isUpdating = true; // ‚úì Muestra "Actualizando..."
    await OnStatusChanged.InvokeAsync((Ticket.Id, newStatus));
    isUpdating = false; // ‚úì Oculta "Actualizando..."
}
```

3. Invoca el callback del padre (Tickets.razor)
4. Pasa el ID del ticket y el nuevo estado

### Paso 3: Callback en Padre (Tickets.razor)

```csharp
private async Task HandleStatusChanged((int id, string status) data)
{
    var success = await TicketService.UpdateTicketStatusAsync(data.id, data.status);
    if (success)
    {
        await LoadTickets(); // Recarga todos los tickets
        selectedTicket = await TicketService.GetTicketByIdAsync(data.id); // Actualiza el modal
    }
}
```

5. Llama al servicio para actualizar en la fuente de datos
6. Si tiene √©xito, recarga la lista completa
7. Actualiza el ticket seleccionado (para refrescar el modal)

### Paso 4: Servicio Actualiza Datos (TicketService.cs)

```csharp
public async Task<bool> UpdateTicketStatusAsync(int id, string newStatus)
{
    await Task.Delay(400); // Simula latencia de red

    var ticket = _tickets.FirstOrDefault(t => t.Id == id);
    if (ticket == null) return false;

    ticket.Status = newStatus;
    _logger.LogInformation($"Ticket {id} actualizado a estado: {newStatus}");
    return true;
}
```

8. Simula 400ms de latencia (realista)
9. Encuentra el ticket en memoria
10. Actualiza su estado
11. Registra el cambio en logs

### Paso 5: Blazor Re-renderiza la UI

```csharp
await LoadTickets();
```

12. Recarga `allTickets` desde el servicio
13. `ApplyFilters()` recalcula `filteredTickets`
14. Blazor detecta cambios de estado
15. Env√≠a solo los CAMBIOS al cliente via SignalR (diff)
16. El navegador actualiza el DOM

**Resultado Visual**:
- ‚úÖ Badge en el modal cambia de color
- ‚úÖ Badge en la lista cambia de color
- ‚úÖ Estad√≠sticas se actualizan
- ‚úÖ Filtros siguen funcionando
- ‚úÖ Todo sin recargar la p√°gina

### Diagrama del Flujo:

```
Usuario Clic
    ‚Üì
TicketDetail.razor (@onclick)
    ‚Üì
ChangeStatus()
    ‚Üì
OnStatusChanged.InvokeAsync()
    ‚Üì
Tickets.razor (HandleStatusChanged)
    ‚Üì
TicketService.UpdateTicketStatusAsync()
    ‚Üì
Actualiza datos en memoria
    ‚Üì
LoadTickets() recarga lista
    ‚Üì
StateHasChanged() (autom√°tico)
    ‚Üì
Blazor calcula diff
    ‚Üì
SignalR env√≠a cambios al cliente
    ‚Üì
DOM actualizado
```

---

# PARTE 9: CARACTER√çSTICAS T√âCNICAS CLAVE

## ‚ö° 15. Blazor Server - Interactividad en Tiempo Real

### ¬øC√≥mo Funciona?

1. **Primera Carga**:
   - El servidor renderiza HTML inicial
   - Se env√≠a al navegador

2. **Conexi√≥n SignalR**:
   - JavaScript en el cliente establece conexi√≥n WebSocket
   - Mantiene conexi√≥n persistente con el servidor

3. **Evento del Usuario**:
   - Usuario hace clic en bot√≥n
   - JavaScript captura el evento
   - Env√≠a mensaje al servidor v√≠a SignalR

4. **Procesamiento en Servidor**:
   - Servidor ejecuta el m√©todo C#
   - Actualiza el estado del componente

5. **UI Diff**:
   - Blazor calcula diferencias (solo lo que cambi√≥)
   - Env√≠a solo los cambios al cliente

6. **Actualizaci√≥n del DOM**:
   - Cliente aplica los cambios al DOM
   - Todo sin recargar la p√°gina

### Ventajas de Blazor Server:

‚úÖ **C√≥digo C# en el servidor**: Seguro, no expone l√≥gica al cliente
‚úÖ **Sin JavaScript**: Escribes C#, no JS
‚úÖ **Bajo peso**: Solo se env√≠an cambios, no todo el HTML
‚úÖ **Debugging**: Puedes usar breakpoints en Visual Studio

### Desventajas:

‚ùå **Requiere conexi√≥n constante**: Si se pierde, la app no funciona
‚ùå **Latencia**: Cada interacci√≥n va al servidor (mitigado con SignalR)
‚ùå **Escalabilidad**: Cada usuario = una conexi√≥n activa

---

## üé® 16. CSS Isolated - Estilos con Scope

### ¬øQu√© es?

Cada componente puede tener su propio archivo CSS que NO afecta a otros componentes.

**Ejemplo**:
```
TicketList.razor
TicketList.razor.css  ‚Üê Estilos solo para TicketList
```

### ¬øC√≥mo Funciona?

1. Blazor genera un identificador √∫nico para el componente
2. A√±ade este ID como atributo a todos los elementos del componente
3. Transforma los selectores CSS para incluir este ID

**Tu CSS**:
```css
.ticket-card {
    background: white;
}
```

**CSS Generado por Blazor**:
```css
.ticket-card[b-abc123] {
    background: white;
}
```

**HTML Generado**:
```html
<div class="ticket-card" b-abc123>
```

### Ventajas:

‚úÖ **No hay conflictos**: Puedes usar clase `.ticket-card` en m√∫ltiples componentes
‚úÖ **Mantenibilidad**: Los estilos est√°n junto al componente
‚úÖ **Refactoring**: Puedes mover/eliminar componente con sus estilos

---

## üîå 17. Inyecci√≥n de Dependencias (DI)

### Patr√≥n de Dise√±o

**Problema que Resuelve**:
- Los componentes necesitan servicios (ej: TicketService)
- No queremos crear instancias manualmente (`new TicketService()`)
- Queremos desacoplar componentes de implementaciones concretas

**Soluci√≥n**:
1. Registrar servicios en `Program.cs`
2. Inyectarlos autom√°ticamente donde se necesiten

### Ciclos de Vida:

**Singleton** (una instancia para toda la app):
```csharp
builder.Services.AddSingleton<ITicketService, TicketService>();
```
- Se crea una vez al iniciar la app
- Todas las peticiones usan la misma instancia
- Perfecto para servicios con estado compartido

**Scoped** (una instancia por petici√≥n HTTP):
```csharp
builder.Services.AddScoped<ITicketService, TicketService>();
```
- Se crea una nueva instancia por cada circuito de Blazor
- En Blazor Server, = por cada conexi√≥n de usuario

**Transient** (nueva instancia cada vez):
```csharp
builder.Services.AddTransient<ITicketService, TicketService>();
```
- Nueva instancia cada vez que se solicita
- Usa m√°s memoria, pero garantiza aislamiento

### Uso en Componentes:

```razor
@inject ITicketService TicketService

@code {
    // Blazor inyecta autom√°ticamente la instancia
    // No necesitas hacer: var service = new TicketService();
}
```

---

## üì± 18. Dise√±o Responsivo

### Media Queries en CSS:

```css
/* Desktop (por defecto) */
.stats {
    grid-template-columns: repeat(4, 1fr); /* 4 columnas */
}

/* Tablet */
@media (max-width: 768px) {
    .stats {
        grid-template-columns: repeat(2, 1fr); /* 2 columnas */
    }
}

/* M√≥vil */
@media (max-width: 480px) {
    .stats {
        grid-template-columns: 1fr; /* 1 columna */
    }
}
```

**Mobile-First vs Desktop-First**:
- Desktop-First: Estilos base para desktop, override para m√≥vil
- Mobile-First: Estilos base para m√≥vil, override para desktop

**Breakpoints Comunes**:
- M√≥vil: < 480px
- Tablet: 768px - 1024px
- Desktop: > 1024px

---

# PARTE 10: PUNTOS CLAVE PARA LA PRESENTACI√ìN

## üéØ 19. Aspectos T√©cnicos a Destacar

### 1. Arquitectura en Capas

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PRESENTATION (Components)         ‚îÇ
‚îÇ   - Blazor Razor Components         ‚îÇ
‚îÇ   - Event Handling                  ‚îÇ
‚îÇ   - UI State Management             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   BUSINESS LOGIC (Services)         ‚îÇ
‚îÇ   - TicketService                   ‚îÇ
‚îÇ   - Validation Logic                ‚îÇ
‚îÇ   - Data Transformation             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   DATA (Models + Data Source)       ‚îÇ
‚îÇ   - Ticket, TicketStatus            ‚îÇ
‚îÇ   - tickets.json (Mock API)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Separaci√≥n de Responsabilidades**:
- Cada capa tiene un prop√≥sito √∫nico
- F√°cil de mantener y testear
- Cambios en una capa no afectan otras

### 2. Patrones de Dise√±o Implementados

‚úÖ **Repository Pattern** (TicketService)
- Abstrae el acceso a datos
- F√°cil cambiar de JSON a DB

‚úÖ **Dependency Injection**
- Desacoplamiento
- Testabilidad

‚úÖ **Component Pattern** (Blazor)
- Componentes reutilizables
- Composici√≥n sobre herencia

‚úÖ **Observer Pattern** (EventCallback)
- Comunicaci√≥n hijo ‚Üí padre
- Desacoplamiento de componentes

### 3. Buenas Pr√°cticas de C#

‚úÖ **Async/Await**:
```csharp
public async Task<List<Ticket>> GetAllTicketsAsync()
```
- Operaciones no bloqueantes
- Mejor rendimiento

‚úÖ **Pattern Matching**:
```csharp
return status switch
{
    "Abierto" => TicketStatus.Abierto,
    _ => TicketStatus.Abierto
};
```
- C√≥digo m√°s limpio
- Compilador verifica casos

‚úÖ **Nullable Reference Types**:
```csharp
private string? errorMessage;
```
- Evita NullReferenceException
- Compilador ayuda a prevenir bugs

‚úÖ **LINQ**:
```csharp
filteredTickets.Where(t => t.Status == currentFilter)
```
- Consultas declarativas
- C√≥digo m√°s legible

### 4. Caracter√≠sticas de Blazor

‚úÖ **Component Lifecycle**:
- `OnInitializedAsync()`: Carga inicial
- `OnParametersSet()`: Cuando cambian par√°metros
- `StateHasChanged()`: Fuerza re-render

‚úÖ **Event Handling**:
- `@onclick`: Click events
- `@oninput`: Input en tiempo real
- `@bind`: Two-way binding

‚úÖ **Conditional Rendering**:
```razor
@if (isLoading) { ... }
else if (errorMessage != null) { ... }
else { ... }
```

‚úÖ **Iteraci√≥n**:
```razor
@foreach (var ticket in Tickets) { ... }
```

### 5. Simulaci√≥n de API REST

Endpoints simulados:
- `GET /tickets` ‚Üí `GetAllTicketsAsync()`
- `GET /tickets/{id}` ‚Üí `GetTicketByIdAsync(id)`
- `PATCH /tickets/{id}` ‚Üí `UpdateTicketStatusAsync(id, status)`

Latencia simulada:
- 300ms para GET
- 400ms para PATCH
- Realismo en la demo

---

## üìù 20. Script de Presentaci√≥n (5 minutos)

### Minuto 1: Introducci√≥n y Arquitectura

"He desarrollado un sistema de gesti√≥n de tickets en Blazor Server siguiendo principios SOLID y arquitectura en capas.

El punto de entrada es **Program.cs** donde:
1. Configuramos Blazor Server con renderizado interactivo
2. Registramos el servicio de tickets usando Inyecci√≥n de Dependencias
3. Configuramos el enrutamiento y middleware

La estructura est√° dividida en:
- **Models**: Definici√≥n de datos (Ticket, TicketStatus)
- **Services**: L√≥gica de negocio (TicketService)
- **Components**: UI interactiva (Pages, Layout, Tickets)

Esto permite separaci√≥n de responsabilidades y facilita el testing."

### Minuto 2: Modelos y Servicios

"En la capa de **Models**, tenemos:
- **Ticket**: POCO con propiedades y m√©todos helper
- **TicketStatus**: Enum para type safety

En **Services**:
- **ITicketService**: Interfaz que define el contrato (abstracci√≥n)
- **TicketService**: Implementaci√≥n que simula una API REST
  - Carga datos desde JSON con fallback a datos en memoria
  - Simula latencia de red (300-400ms) para realismo
  - Logging estructurado con ILogger

El servicio est√° registrado como Singleton, compartido por toda la app."

### Minuto 3: Componentes y Flujo de Datos

"Los componentes siguen un patr√≥n de composici√≥n:

- **Tickets.razor**: Componente padre, orquesta todo
  - Mantiene el estado (allTickets, filteredTickets)
  - Recibe eventos de componentes hijos v√≠a EventCallback

- **TicketFilters**: Componente hijo para b√∫squeda y filtros
  - Input en tiempo real con `@oninput`
  - Notifica al padre cuando cambia algo

- **TicketList**: Muestra tickets con formato
  - M√©todos helper para truncar texto, formatear fechas

- **TicketDetail**: Modal lateral
  - Permite cambiar estado
  - Usa `stopPropagation` para evitar cerrar al hacer clic dentro

El flujo es unidireccional: Padre ‚Üí Hijo (datos), Hijo ‚Üí Padre (eventos)."

### Minuto 4: Caracter√≠sticas T√©cnicas

"Caracter√≠sticas clave implementadas:

1. **Blazor Server Interactivo**:
   - Renderizado del lado del servidor
   - SignalR para comunicaci√≥n en tiempo real
   - `@rendermode InteractiveServer` en componentes

2. **CSS Isolated**:
   - Cada componente tiene su CSS
   - Sin conflictos de estilos
   - Blazor genera scopes autom√°ticamente

3. **Responsive Design**:
   - Media queries para m√≥vil, tablet, desktop
   - Grid layout adaptativo
   - Modal full-screen en m√≥vil

4. **UX Improvements**:
   - Estados de carga (spinner)
   - Manejo de errores
   - Formato de fechas relativas
   - Latencia simulada para feedback visual"

### Minuto 5: Demo en Vivo

"Perm√≠tanme mostrar la funcionalidad:

1. **Filtros**: [Click "Abiertos"] ‚Üí 5 tickets sin recargar p√°gina
2. **B√∫squeda**: [Escribir "sesi√≥n"] ‚Üí Filtrado en tiempo real
3. **Combinaci√≥n**: [Filtros + b√∫squeda funcionan juntos]
4. **Detalle**: [Click en ticket] ‚Üí Modal con animaci√≥n
5. **PATCH**: [Cambiar estado] ‚Üí Ver latencia simulada
6. **Persistencia**: [Cerrar y reabrir] ‚Üí Cambio persiste
7. **Responsive**: [F12, modo m√≥vil] ‚Üí Layout se adapta

Todo funciona sin recargar la p√°gina gracias a Blazor Server."

---

## üèÜ 21. Preguntas Frecuentes Anticipadas

### "¬øPor qu√© Blazor Server y no Blazor WebAssembly?"

"Blazor Server permite:
- C√≥digo C# seguro en el servidor
- Menos payload inicial (mejor first load)
- Debugging m√°s f√°cil
- Ideal para intranets con conexi√≥n estable

WebAssembly ser√≠a mejor para:
- Apps que funcionan offline
- Reducir carga del servidor
- Clientes con conexi√≥n intermitente"

### "¬øC√≥mo escalar√≠a esto en producci√≥n?"

"Para producci√≥n real:
1. **Backend**: API REST real con ASP.NET Core Web API
2. **Base de Datos**: SQL Server o PostgreSQL con Entity Framework Core
3. **Caching**: Redis para mejorar performance
4. **SignalR Backplane**: Azure SignalR Service para m√∫ltiples servidores
5. **Autenticaci√≥n**: Identity con JWT
6. **Testing**: Unit tests con xUnit, Mocks con Moq"

### "¬øC√≥mo manejar√≠as estado m√°s complejo?"

"Opciones:
1. **Fluxor**: State management pattern como Redux
2. **Blazor State**: Librer√≠a de manejo de estado
3. **Cascading Parameters**: Para estado compartido entre componentes
4. **Browser Storage**: LocalStorage para persistencia cliente"

### "¬øQu√© mejoras a√±adir√≠as?"

"Siguientes pasos:
1. **SignalR Hub**: Actualizaciones en tiempo real entre usuarios
2. **Paginaci√≥n**: Para grandes vol√∫menes de tickets
3. **Ordenamiento**: Por fecha, prioridad, estado
4. **Comentarios**: Sistema de conversaci√≥n en tickets
5. **Adjuntos**: Subida de archivos
6. **Notificaciones**: Push notifications cuando cambia estado
7. **Dashboard**: Gr√°ficos y m√©tricas con Chart.js
8. **Export**: Exportar a PDF/Excel"

---

## üìö 22. Recursos y Referencias

### Tecnolog√≠as Utilizadas:

- **.NET 9.0**: Framework principal
- **Blazor Server**: UI framework
- **C# 12**: Lenguaje de programaci√≥n
- **System.Text.Json**: Serializaci√≥n
- **SignalR**: Comunicaci√≥n tiempo real (impl√≠cito en Blazor Server)
- **CSS3**: Estilos con Grid y Flexbox

### Patrones y Principios:

- **SOLID Principles**
- **Repository Pattern**
- **Dependency Injection**
- **Component Pattern**
- **Observer Pattern** (EventCallback)

### Buenas Pr√°cticas:

- ‚úÖ Separaci√≥n de responsabilidades
- ‚úÖ CSS Isolated
- ‚úÖ Async/Await
- ‚úÖ Logging estructurado
- ‚úÖ Manejo de errores
- ‚úÖ Nullable reference types
- ‚úÖ Pattern matching
- ‚úÖ LINQ

---

Espero que esta gu√≠a te ayude a presentar tu proyecto de manera profesional. ¬°√âxito en tu prueba t√©cnica! üöÄ
